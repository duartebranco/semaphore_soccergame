//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct ipc_perm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int16_t e6;
};

struct sembuf {
    int16_t e0;
    int16_t e1;
    int16_t e2;
};

struct shmid_ds {
    struct ipc_perm e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
    int64_t * e9;
    int64_t * e10;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void arrive(int32_t id);
void closeLog(struct _IO_FILE * fic);
void createLog(char * nFic2, int32_t * p_fSt);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_11d0(int64_t * d);
int32_t function_11e0(int32_t key, int32_t nsems, int32_t semflg);
void function_11f0(int32_t seed);
char * function_1200(char * dest, char * src);
int32_t function_1210(int64_t * shmaddr);
int32_t function_1220(void);
int32_t function_1230(struct _IO_FILE * stream);
void function_1240(void);
void function_1250(struct _IO_FILE * stream, char * buf);
void function_1260(char * assertion, char * file, int32_t line, char * function);
struct _IO_FILE * function_1270(char * filename, char * modes, struct _IO_FILE * stream);
int32_t function_1280(int32_t c, struct _IO_FILE * stream);
int32_t function_1290(struct _IO_FILE * stream, char * format, ...);
int32_t function_12a0(char * nptr, char ** endptr, int32_t base);
int32_t function_12b0(void);
int32_t function_12c0(struct _IO_FILE * stream);
int32_t function_12d0(int32_t shmid2, int32_t cmd, struct shmid_ds * buf);
struct _IO_FILE * function_12e0(char * filename, char * modes);
void function_12f0(char * s);
int32_t function_1300(int32_t semid, int32_t semnum, int32_t cmd, ...);
int64_t * function_1310(int32_t shmid2, int64_t * shmaddr, int32_t shmflg);
int32_t function_1320(int32_t key, int32_t size, int32_t shmflg);
int32_t function_1330(int32_t semid, struct sembuf * sops, int32_t nsops);
void function_1340(int32_t status);
int32_t function_1350(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_1360(char * pathname, int32_t proj_id);
int32_t function_1370(int32_t useconds);
struct _IO_FILE * openLog(char * nFic2, char * mode);
int32_t playerConstituteTeam(int32_t id);
void playUntilEnd(int32_t id, int32_t team);
void printHeader(struct _IO_FILE * fic, int32_t * p_fSt);
int64_t register_tm_clones(void);
void saveState(char * nFic2, int32_t * p_fSt);
int32_t semConnect(int32_t key);
int32_t semCreate(int32_t key, int32_t snum);
int32_t semDestroy(int32_t semgid2);
int32_t semDown(int32_t semgid2, int32_t sindex);
int32_t semSignal(int32_t semgid2);
int32_t semUp(int32_t semgid2, int32_t sindex);
int32_t shmemAttach(int32_t shmid2, char ** pAttAdd);
int32_t shmemConnect(int32_t key);
int32_t shmemCreate(int32_t key, int32_t size);
int32_t shmemDestroy(int32_t shmid2);
int32_t shmemDettach(char * attAdd);
void waitReferee(int32_t id, int32_t team);

// --------------------- Global Variables ---------------------

char * g1 = "P"; // 0x327d
char * g2 = "G"; // 0x3287
char * g3 = "R"; // 0x3289
int64_t g4 = 0x1460; // 0x4cf0
int64_t g5 = 0x1420; // 0x4cf8
struct _IO_FILE * g6 = NULL; // 0x5020
struct _IO_FILE * g7 = NULL; // 0x5040
char g8 = 0; // 0x5048
int32_t g9 = 0x74756f64; // 0x780
char nFic[51]; // 0x5060
int32_t semgid = 0; // 0x5098
int32_t * sh = NULL; // 0x50a0
int32_t shmid = 0; // 0x5094
int32_t g10;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x4fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g10;
    }
    // 0x1016
    return result;
}

// Address range: 0x11d0 - 0x11db
void function_11d0(int64_t * d) {
    // 0x11d0
    __cxa_finalize(d);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(int32_t key, int32_t nsems, int32_t semflg) {
    // 0x11e0
    return semget(key, nsems, semflg);
}

// Address range: 0x11f0 - 0x11fb
void function_11f0(int32_t seed) {
    // 0x11f0
    srandom(seed);
}

// Address range: 0x1200 - 0x120b
char * function_1200(char * dest, char * src) {
    // 0x1200
    return strcpy(dest, src);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int64_t * shmaddr) {
    // 0x1210
    return shmdt(shmaddr);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(void) {
    // 0x1220
    return getpid();
}

// Address range: 0x1230 - 0x123b
int32_t function_1230(struct _IO_FILE * stream) {
    // 0x1230
    return fclose(stream);
}

// Address range: 0x1240 - 0x124b
void function_1240(void) {
    // 0x1240
    __stack_chk_fail();
}

// Address range: 0x1250 - 0x125b
void function_1250(struct _IO_FILE * stream, char * buf) {
    // 0x1250
    setbuf(stream, buf);
}

// Address range: 0x1260 - 0x126b
void function_1260(char * assertion, char * file, int32_t line, char * function) {
    // 0x1260
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x1270 - 0x127b
struct _IO_FILE * function_1270(char * filename, char * modes, struct _IO_FILE * stream) {
    // 0x1270
    return freopen(filename, modes, stream);
}

// Address range: 0x1280 - 0x128b
int32_t function_1280(int32_t c, struct _IO_FILE * stream) {
    // 0x1280
    return fputc(c, stream);
}

// Address range: 0x1290 - 0x129b
int32_t function_1290(struct _IO_FILE * stream, char * format, ...) {
    // 0x1290
    return fprintf(stream, format);
}

// Address range: 0x12a0 - 0x12ab
int32_t function_12a0(char * nptr, char ** endptr, int32_t base) {
    // 0x12a0
    return strtol(nptr, endptr, base);
}

// Address range: 0x12b0 - 0x12bb
int32_t function_12b0(void) {
    // 0x12b0
    return random();
}

// Address range: 0x12c0 - 0x12cb
int32_t function_12c0(struct _IO_FILE * stream) {
    // 0x12c0
    return fflush(stream);
}

// Address range: 0x12d0 - 0x12db
int32_t function_12d0(int32_t shmid2, int32_t cmd, struct shmid_ds * buf) {
    // 0x12d0
    return shmctl(shmid2, cmd, buf);
}

// Address range: 0x12e0 - 0x12eb
struct _IO_FILE * function_12e0(char * filename, char * modes) {
    // 0x12e0
    return fopen(filename, modes);
}

// Address range: 0x12f0 - 0x12fb
void function_12f0(char * s) {
    // 0x12f0
    perror(s);
}

// Address range: 0x1300 - 0x130b
int32_t function_1300(int32_t semid, int32_t semnum, int32_t cmd, ...) {
    // 0x1300
    return semctl(semid, semnum, cmd);
}

// Address range: 0x1310 - 0x131b
int64_t * function_1310(int32_t shmid2, int64_t * shmaddr, int32_t shmflg) {
    // 0x1310
    return shmat(shmid2, shmaddr, shmflg);
}

// Address range: 0x1320 - 0x132b
int32_t function_1320(int32_t key, int32_t size, int32_t shmflg) {
    // 0x1320
    return shmget(key, size, shmflg);
}

// Address range: 0x1330 - 0x133b
int32_t function_1330(int32_t semid, struct sembuf * sops, int32_t nsops) {
    // 0x1330
    return semop(semid, sops, nsops);
}

// Address range: 0x1340 - 0x134b
void function_1340(int32_t status) {
    // 0x1340
    exit(status);
}

// Address range: 0x1350 - 0x135b
int32_t function_1350(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x1350
    return fwrite(ptr, size, n, s);
}

// Address range: 0x1360 - 0x136b
int32_t function_1360(char * pathname, int32_t proj_id) {
    // 0x1360
    return ftok(pathname, proj_id);
}

// Address range: 0x1370 - 0x137b
int32_t function_1370(int32_t useconds) {
    // 0x1370
    return usleep(useconds);
}

// Address range: 0x1380 - 0x13af
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1380
    int64_t v1; // 0x1380
    __libc_start_main(0x1469, (int32_t)a4, (char **)&v1, (void (*)())0x22c0, (void (*)())0x2330, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x13b0 - 0x13d9
int64_t deregister_tm_clones(void) {
    // 0x13b0
    return 0x5010;
}

// Address range: 0x13e0 - 0x1419
int64_t register_tm_clones(void) {
    // 0x13e0
    return 0;
}

// Address range: 0x1420 - 0x1459
int64_t __do_global_dtors_aux(void) {
    // 0x1420
    if (g8 != 0) {
        // 0x1458
        int64_t result; // 0x1420
        return result;
    }
    // 0x142d
    if (*(int64_t *)0x4ff8 != 0) {
        // 0x143b
        __cxa_finalize((int64_t *)*(int64_t *)0x5008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1447
    g8 = 1;
    return result2;
}

// Address range: 0x1460 - 0x1469
int64_t frame_dummy(void) {
    // 0x1460
    return register_tm_clones();
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemPlayer.c
// Address range: 0x1469 - 0x16cb
// Line range:    63 - 131
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x147c
    int32_t v2; // 0x1469
    if (argc == 4) {
        int64_t v3 = (int64_t)argv; // 0x14d8
        char * endptr; // bp-24, 0x1469
        int32_t str_as_l = strtol((char *)*(int64_t *)(v3 + 8), &endptr, 0); // 0x14f2
        if (str_as_l < 10 == *endptr == 0) {
            // 0x1535
            strcpy(nFic, (char *)*(int64_t *)(v3 + 16));
            freopen((char *)*(int64_t *)(v3 + 24), "w", g7);
            setbuf(g7, NULL);
            int32_t v4 = ftok(".", 97); // 0x1590
            if (v4 == -1) {
                // 0x159e
                perror("error on generating the key");
                exit(1);
                // UNREACHABLE
            }
            int32_t v5 = semConnect(v4); // 0x15b9
            semgid = v5;
            if (v5 != -1) {
                int32_t v6 = shmemConnect(v4); // 0x15ea
                shmid = v6;
                if (v6 != -1) {
                    // 0x1616
                    if (shmemAttach(v6, (char **)&sh) != -1) {
                        // 0x1642
                        srandom(getpid());
                        arrive(str_as_l);
                        int32_t v7 = playerConstituteTeam(str_as_l); // 0x165d
                        if (v7 != 0) {
                            // 0x166b
                            waitReferee(str_as_l, v7);
                            playUntilEnd(str_as_l, v7);
                        }
                        // 0x1689
                        v2 = 0;
                        if (shmemDettach((char *)sh) == -1) {
                            // 0x169d
                            perror("error on unmapping the shared region off the process address space");
                            v2 = 1;
                        }
                    } else {
                        // 0x162f
                        perror("error on mapping the shared region on the process address space");
                        v2 = 1;
                    }
                } else {
                    // 0x1600
                    perror("error on connecting to the shared memory region");
                    v2 = 1;
                }
            } else {
                // 0x15cf
                perror("error on connecting to the semaphore set");
                v2 = 1;
            }
        } else {
            // 0x150b
            fwrite((int64_t *)"Player process identification is wrong!\n", 1, 40, g7);
            v2 = 1;
        }
    } else {
        // 0x1491
        freopen("error_PL", "a", g7);
        fwrite((int64_t *)"Number of parameters is incorrect!\n", 1, 35, g7);
        v2 = 1;
    }
    int32_t result = v2; // 0x16c2
    if (v1 != __readfsqword(40)) {
        // 0x16c4
        __stack_chk_fail();
        result = &g10;
    }
    // 0x16c9
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemPlayer.c
// Address range: 0x16cb - 0x17b9
// Line range:    140 - 157
void arrive(int32_t id) {
    // 0x16cb
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x16f8
        perror("error on the up operation for semaphore access (PL)");
        exit(1);
        // UNREACHABLE
    }
    // 0x170e
    *(int32_t *)(4 * (int64_t)id + (int64_t)sh) = 65;
    saveState(nFic, sh);
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1756
        perror("error on the down operation for semaphore access (PL)");
        exit(1);
        // UNREACHABLE
    }
    int128_t v1 = __asm_mulsd(__asm_cvtsi2sd((int64_t)random()), __asm_movsd(0x4069000000000000)); // 0x177e
    int128_t v2 = __asm_mulsd(__asm_movsd(0x40c3880000000000), v1); // 0x178a
    int128_t v3 = __asm_movapd(__asm_divsd(v2, __asm_movsd(0x41e0000000000000))); // 0x179a
    usleep((int32_t)__asm_cvttsd2si(__asm_addsd(__asm_movsd(0x4049000000000000), v3)));
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemPlayer.c
// Address range: 0x17b9 - 0x1a45
// Line range:    174 - 230
int32_t playerConstituteTeam(int32_t id) {
    // 0x17b9
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x17ed
        perror("error on the up operation for semaphore access (PL)");
        exit(1);
        // UNREACHABLE
    }
    int32_t * v1 = (int32_t *)((int64_t)sh + 68); // 0x180e
    *v1 = *v1 + 1;
    int32_t * v2 = (int32_t *)((int64_t)sh + 76); // 0x181e
    *v2 = *v2 + 1;
    int64_t v3 = (int64_t)sh;
    int32_t v4; // 0x17b9
    char v5; // 0x17b9
    if (*(int32_t *)(v3 + 68) > 8) {
        // 0x1996
        *(int32_t *)(4 * (int64_t)id + v3) = 76;
        saveState(nFic, sh);
        v4 = 0;
        v5 = 0;
        goto lab_0x19c7;
    } else {
        // 0x183a
        if (*(int32_t *)(v3 + 76) < 4) {
            goto lab_0x1966;
        } else {
            // 0x184d
            if (*(int32_t *)(v3 + 80) < 1) {
                goto lab_0x1966;
            } else {
                // 0x185f
                *(int32_t *)(4 * (int64_t)id + v3) = 70;
                saveState(nFic, sh);
                int32_t * v6 = (int32_t *)((int64_t)sh + 76); // 0x1890
                *v6 = *v6 - 4;
                int32_t * v7 = (int32_t *)((int64_t)sh + 80); // 0x18a7
                *v7 = *v7 - 1;
                semUp(semgid, *(int32_t *)((int64_t)sh + 96));
                semDown(semgid, *(int32_t *)((int64_t)sh + 112));
                for (int32_t i = 0; i < 3; i++) {
                    // 0x18f2
                    semUp(semgid, *(int32_t *)((int64_t)sh + 92));
                    semDown(semgid, *(int32_t *)((int64_t)sh + 112));
                }
                int32_t * v8 = (int32_t *)((int64_t)sh + 84); // 0x1935
                int32_t v9 = *v8;
                *v8 = v9 + 1;
                semUp(semgid, *(int32_t *)((int64_t)sh + 108));
                v4 = v9;
                v5 = 0;
                goto lab_0x19c7;
            }
        }
    }
  lab_0x19c7:
    // 0x19c7
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x19e5
        perror("error on the down operation for semaphore access (PL)");
        exit(1);
        // UNREACHABLE
    }
    int32_t result = v4; // 0x19ff
    if (v5 != 0) {
        // 0x1a01
        semDown(semgid, *(int32_t *)((int64_t)sh + 92));
        int64_t v10 = (int64_t)sh; // 0x1a1a
        semUp(semgid, *(int32_t *)(v10 + 112));
        result = *(int32_t *)(v10 + 84);
    }
    // 0x1a40
    return result;
  lab_0x1966:
    // 0x1966
    *(int32_t *)(4 * (int64_t)id + v3) = 87;
    saveState(nFic, sh);
    v4 = 0;
    v5 = 1;
    goto lab_0x19c7;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemPlayer.c
// Address range: 0x1a45 - 0x1b2c
// Line range:    241 - 262
void waitReferee(int32_t id, int32_t team) {
    // 0x1a45
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1a75
        perror("error on the up operation for semaphore access (PL)");
        exit(1);
        // UNREACHABLE
    }
    // 0x1a8b
    *(int32_t *)(4 * (int64_t)id + (int64_t)sh) = team != 1 ? 83 : 115;
    saveState(nFic, sh);
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) != -1) {
        // 0x1af7
        semDown(semgid, *(int32_t *)((int64_t)sh + 100));
        semUp(semgid, *(int32_t *)((int64_t)sh + 116));
        return;
    }
    // 0x1ae1
    perror("error on the down operation for semaphore access (PL)");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemPlayer.c
// Address range: 0x1b2c - 0x1bfa
// Line range:    273 - 292
void playUntilEnd(int32_t id, int32_t team) {
    // 0x1b2c
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1b5c
        perror("error on the up operation for semaphore access (PL)");
        exit(1);
        // UNREACHABLE
    }
    // 0x1b72
    *(int32_t *)(4 * (int64_t)id + (int64_t)sh) = team != 1 ? 80 : 112;
    saveState(nFic, sh);
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) != -1) {
        // 0x1bde
        semDown(semgid, *(int32_t *)((int64_t)sh + 104));
        return;
    }
    // 0x1bc8
    perror("error on the down operation for semaphore access (PL)");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1bfa - 0x1c23
// Line range:    35 - 38
int32_t shmemCreate(int32_t key, int32_t size) {
    // 0x1bfa
    return shmget(key, size, (int32_t)&g9);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1c23 - 0x1c48
// Line range:    51 - 54
int32_t shmemConnect(int32_t key) {
    // 0x1c23
    return shmget(key, 1, 384);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1c48 - 0x1c6d
// Line range:    67 - 70
int32_t shmemDestroy(int32_t shmid2) {
    // 0x1c48
    return shmctl(shmid2, IPC_RMID, NULL);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1c6d - 0x1cb8
// Line range:    84 - 94
int32_t shmemAttach(int32_t shmid2, char ** pAttAdd) {
    int64_t * v1 = shmat(shmid2, NULL, 0); // 0x1c8f
    int32_t result = 1; // 0x1c9d
    if (v1 != (int64_t *)-1) {
        // 0x1c9f
        *(int64_t *)pAttAdd = (int64_t)v1;
        result = 0;
    }
    // 0x1cb6
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1cb8 - 0x1cd6
// Line range:    108 - 111
int32_t shmemDettach(char * attAdd) {
    // 0x1cb8
    return shmdt((int64_t *)attAdd);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1cd6 - 0x1d03
// Line range:    39 - 42
int32_t semCreate(int32_t key, int32_t snum) {
    // 0x1cd6
    return semget(key, snum + 1, (int32_t)&g9);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1d03 - 0x1da4
// Line range:    55 - 65
int32_t semConnect(int32_t key) {
    int64_t v1 = __readfsqword(40); // 0x1d12
    int16_t sops = 0; // bp-28, 0x1d21
    int32_t semid = semget(key, 1, 384); // 0x1d54
    int32_t v2 = -1; // 0x1d60
    if (semid != -1) {
        // 0x1d69
        v2 = semop(semid, (struct sembuf *)&sops, 2) != -1 ? semid : -1;
    }
    int32_t result = v2; // 0x1d9b
    if (v1 != __readfsqword(40)) {
        // 0x1d9d
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1da2
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1da4 - 0x1dd3
// Line range:    78 - 81
int32_t semDestroy(int32_t semgid2) {
    // 0x1da4
    return semctl(semgid2, 0, IPC_RMID);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1dd3 - 0x1e2f
// Line range:    94 - 99
int32_t semSignal(int32_t semgid2) {
    int64_t v1 = __readfsqword(40); // 0x1de2
    int16_t sops = 0; // bp-22, 0x1df1
    int32_t result = semop(semgid2, (struct sembuf *)&sops, 1); // 0x1e26
    if (v1 != __readfsqword(40)) {
        // 0x1e28
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1e2d
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1e2f - 0x1eba
// Line range:    113 - 120
int32_t semDown(int32_t semgid2, int32_t sindex) {
    int64_t v1 = __readfsqword(40); // 0x1e41
    int32_t sops = 0; // bp-22, 0x1e50
    if (sindex == 0) {
        // 0x1e68
        __assert_fail("sindex>0", "semaphore.c", 117, "semDown");
    }
    // 0x1e87
    sops = 0x10000 * sindex >> 16;
    int32_t result = semop(semgid2, (struct sembuf *)&sops, 1); // 0x1eb1
    if (v1 != __readfsqword(40)) {
        // 0x1eb3
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1eb8
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1eba - 0x1f45
// Line range:    134 - 141
int32_t semUp(int32_t semgid2, int32_t sindex) {
    int64_t v1 = __readfsqword(40); // 0x1ecc
    int32_t sops = 0; // bp-22, 0x1edb
    if (sindex == 0) {
        // 0x1ef3
        __assert_fail("sindex>0", "semaphore.c", 138, "semUp");
    }
    // 0x1f12
    sops = 0x10000 * sindex >> 16;
    int32_t result = semop(semgid2, (struct sembuf *)&sops, 1); // 0x1f3c
    if (v1 != __readfsqword(40)) {
        // 0x1f3e
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1f43
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x1f45 - 0x1fe8
// Line range:    29 - 48
struct _IO_FILE * openLog(char * nFic2, char * mode) {
    // 0x1f45
    if (nFic2 == NULL) {
        // 0x1fe6
        return g6;
    }
    int64_t v1; // 0x1f45
    if ((char)v1 == 0) {
        // 0x1fe6
        return g6;
    }
    // 0x1f74
    fprintf(g7, "%d opening log %s %s\n", (int64_t)getpid(), nFic2, mode);
    struct _IO_FILE * file = fopen(nFic2, mode); // 0x1fbc
    if (file != NULL) {
        // 0x1fe6
        return file;
    }
    // 0x1fcc
    perror("error on opening log file");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x1fe8 - 0x2049
// Line range:    50 - 61
void closeLog(struct _IO_FILE * fic) {
    // 0x1fe8
    if (g7 == fic || g6 == fic) {
        // 0x2012
        fflush(fic);
        // 0x2047
        return;
    }
    // 0x2020
    if (fclose(fic) != -1) {
        // 0x2047
        return;
    }
    // 0x2031
    perror("error on closing of log file");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x2049 - 0x2142
// Line range:    63 - 85
void printHeader(struct _IO_FILE * fic, int32_t * p_fSt) {
    int64_t v1 = (int64_t)p_fSt; // 0x208e
    int32_t * v2 = (int32_t *)(v1 + 56); // 0x2092
    struct _IO_FILE * stream = (struct _IO_FILE *)(0x100000000 * (int64_t)fic >> 32);
    int32_t v3 = 0; // 0x2098
    if (*v2 != 0) {
        fprintf(stream, " %s%02d", (char *)&g1, (int64_t)v3);
        v3++;
        while ((int64_t)v3 < (int64_t)*v2) {
            // 0x2066
            fprintf(stream, " %s%02d", (char *)&g1, (int64_t)v3);
            v3++;
        }
    }
    // 0x209a
    fputc(32, stream);
    int32_t * v4 = (int32_t *)(v1 + 60); // 0x20e0
    int32_t v5 = 0; // 0x20e6
    if (*v4 == 0) {
        // 0x20e8
        fputc(32, stream);
        fprintf(stream, " %s%02d", (char *)&g3, 1);
        fputc(32, stream);
        fputc(10, stream);
        return;
    }
    fprintf(stream, " %s%02d", (char *)&g2, (int64_t)v5);
    v5++;
    while ((int64_t)v5 < (int64_t)*v4) {
        // 0x20b4
        fprintf(stream, " %s%02d", (char *)&g2, (int64_t)v5);
        v5++;
    }
    // 0x20e8
    fputc(32, stream);
    fprintf(stream, " %s%02d", (char *)&g3, 1);
    fputc(32, stream);
    fputc(10, stream);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x2142 - 0x21ac
// Line range:    101 - 113
void createLog(char * nFic2, int32_t * p_fSt) {
    struct _IO_FILE * stream = openLog(nFic2, "w"); // 0x2164
    fprintf(stream, "%21cSoccerGame - Description of the internal state\n\n", 32);
    printHeader(stream, p_fSt);
    closeLog(stream);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x21ac - 0x22b9
// Line range:    128 - 153
void saveState(char * nFic2, int32_t * p_fSt) {
    struct _IO_FILE * stream = openLog(nFic2, (char *)0x32c5); // 0x21ce
    int64_t v1 = (int64_t)p_fSt; // 0x2209
    int32_t * v2 = (int32_t *)(v1 + 56); // 0x220d
    if (*v2 != 0) {
        fprintf(stream, "%4c", (char)*(int32_t *)((0 >> 30) + v1));
        int64_t v3 = 1; // 0x2205
        int64_t v4 = 0x100000000 * v3;
        int64_t v5 = v3 & 0xffffffff; // 0x2213
        while (v4 >> 32 < (int64_t)*v2) {
            // 0x21e0
            fprintf(stream, "%4c", (char)*(int32_t *)((v4 >> 30) + v1));
            v3 = v5 + 1;
            v4 = 0x100000000 * v3;
            v5 = v3 & 0xffffffff;
        }
    }
    // 0x2215
    fputc(32, stream);
    int32_t * v6 = (int32_t *)(v1 + 60); // 0x2261
    if (*v6 != 0) {
        int32_t v7 = 0; // 0x2259
        fprintf(stream, "%4c", (char)*(int32_t *)(40 + v1));
        v7++;
        int64_t v8 = v7; // 0x2267
        while (v8 < (int64_t)*v6) {
            // 0x222f
            fprintf(stream, "%4c", (char)*(int32_t *)(v1 + 40 + 4 * v8));
            v7++;
            v8 = v7;
        }
    }
    // 0x2269
    fputc(32, stream);
    fprintf(stream, "%4c", (char)*(int32_t *)(v1 + 52));
    fputc(10, stream);
    closeLog(stream);
}

// Address range: 0x22c0 - 0x2325
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = _init(); // 0x22ec
    if ((int64_t)&g5 - (int64_t)&g4 >> 3 == 0) {
        // 0x2316
        return result;
    }
    int64_t v1 = 0; // 0x22f5
    while (v1 + 1 != (int64_t)&g5 - (int64_t)&g4 >> 3) {
        // 0x2300
        v1++;
    }
    // 0x2316
    return result;
}

// Address range: 0x2330 - 0x2335
int64_t __libc_csu_fini(void) {
    // 0x2330
    int64_t result; // 0x2330
    return result;
}

// Address range: 0x2338 - 0x2345
int64_t _fini(void) {
    // 0x2338
    int64_t result; // 0x2338
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (9.4.0)
// Detected functions: 57

