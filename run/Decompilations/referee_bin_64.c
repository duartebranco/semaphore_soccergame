//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct ipc_perm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int16_t e6;
};

struct sembuf {
    int16_t e0;
    int16_t e1;
    int16_t e2;
};

struct shmid_ds {
    struct ipc_perm e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
    int64_t * e9;
    int64_t * e10;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void arrive(void);
void closeLog(struct _IO_FILE * fic);
void createLog(char * nFic2, int32_t * p_fSt);
int64_t deregister_tm_clones(void);
void endGame(void);
int64_t frame_dummy(void);
void function_11c0(int64_t * d);
int32_t function_11d0(int32_t key, int32_t nsems, int32_t semflg);
void function_11e0(int32_t seed);
char * function_11f0(char * dest, char * src);
int32_t function_1200(int64_t * shmaddr);
int32_t function_1210(void);
int32_t function_1220(struct _IO_FILE * stream);
void function_1230(void);
void function_1240(struct _IO_FILE * stream, char * buf);
void function_1250(char * assertion, char * file, int32_t line, char * function);
struct _IO_FILE * function_1260(char * filename, char * modes, struct _IO_FILE * stream);
int32_t function_1270(int32_t c, struct _IO_FILE * stream);
int32_t function_1280(struct _IO_FILE * stream, char * format, ...);
int32_t function_1290(void);
int32_t function_12a0(struct _IO_FILE * stream);
int32_t function_12b0(int32_t shmid2, int32_t cmd, struct shmid_ds * buf);
struct _IO_FILE * function_12c0(char * filename, char * modes);
void function_12d0(char * s);
int32_t function_12e0(int32_t semid, int32_t semnum, int32_t cmd, ...);
int64_t * function_12f0(int32_t shmid2, int64_t * shmaddr, int32_t shmflg);
int32_t function_1300(int32_t key, int32_t size, int32_t shmflg);
int32_t function_1310(int32_t semid, struct sembuf * sops, int32_t nsops);
void function_1320(int32_t status);
int32_t function_1330(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_1340(char * pathname, int32_t proj_id);
int32_t function_1350(int32_t useconds);
struct _IO_FILE * openLog(char * nFic2, char * mode);
void play(void);
void printHeader(struct _IO_FILE * fic, int32_t * p_fSt);
int64_t register_tm_clones(void);
void saveState(char * nFic2, int32_t * p_fSt);
int32_t semConnect(int32_t key);
int32_t semCreate(int32_t key, int32_t snum);
int32_t semDestroy(int32_t semgid2);
int32_t semDown(int32_t semgid2, int32_t sindex);
int32_t semSignal(int32_t semgid2);
int32_t semUp(int32_t semgid2, int32_t sindex);
int32_t shmemAttach(int32_t shmid2, char ** pAttAdd);
int32_t shmemConnect(int32_t key);
int32_t shmemCreate(int32_t key, int32_t size);
int32_t shmemDestroy(int32_t shmid2);
int32_t shmemDettach(char * attAdd);
void startGame(void);
void waitForTeams(void);

// --------------------- Global Variables ---------------------

char * g1 = "P"; // 0x3215
char * g2 = "G"; // 0x321f
char * g3 = "R"; // 0x3221
int64_t g4 = 0x1440; // 0x4cf8
int64_t g5 = 0x1400; // 0x4d00
struct _IO_FILE * g6 = NULL; // 0x5020
struct _IO_FILE * g7 = NULL; // 0x5040
char g8 = 0; // 0x5048
int32_t g9 = 0x7375006e; // 0x780
char nFic[51]; // 0x5060
int32_t semgid = 0; // 0x5098
int32_t * sh = NULL; // 0x50a0
int32_t shmid = 0; // 0x5094
int32_t g10;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x4fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g10;
    }
    // 0x1016
    return result;
}

// Address range: 0x11c0 - 0x11cb
void function_11c0(int64_t * d) {
    // 0x11c0
    __cxa_finalize(d);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t key, int32_t nsems, int32_t semflg) {
    // 0x11d0
    return semget(key, nsems, semflg);
}

// Address range: 0x11e0 - 0x11eb
void function_11e0(int32_t seed) {
    // 0x11e0
    srandom(seed);
}

// Address range: 0x11f0 - 0x11fb
char * function_11f0(char * dest, char * src) {
    // 0x11f0
    return strcpy(dest, src);
}

// Address range: 0x1200 - 0x120b
int32_t function_1200(int64_t * shmaddr) {
    // 0x1200
    return shmdt(shmaddr);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(void) {
    // 0x1210
    return getpid();
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(struct _IO_FILE * stream) {
    // 0x1220
    return fclose(stream);
}

// Address range: 0x1230 - 0x123b
void function_1230(void) {
    // 0x1230
    __stack_chk_fail();
}

// Address range: 0x1240 - 0x124b
void function_1240(struct _IO_FILE * stream, char * buf) {
    // 0x1240
    setbuf(stream, buf);
}

// Address range: 0x1250 - 0x125b
void function_1250(char * assertion, char * file, int32_t line, char * function) {
    // 0x1250
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x1260 - 0x126b
struct _IO_FILE * function_1260(char * filename, char * modes, struct _IO_FILE * stream) {
    // 0x1260
    return freopen(filename, modes, stream);
}

// Address range: 0x1270 - 0x127b
int32_t function_1270(int32_t c, struct _IO_FILE * stream) {
    // 0x1270
    return fputc(c, stream);
}

// Address range: 0x1280 - 0x128b
int32_t function_1280(struct _IO_FILE * stream, char * format, ...) {
    // 0x1280
    return fprintf(stream, format);
}

// Address range: 0x1290 - 0x129b
int32_t function_1290(void) {
    // 0x1290
    return random();
}

// Address range: 0x12a0 - 0x12ab
int32_t function_12a0(struct _IO_FILE * stream) {
    // 0x12a0
    return fflush(stream);
}

// Address range: 0x12b0 - 0x12bb
int32_t function_12b0(int32_t shmid2, int32_t cmd, struct shmid_ds * buf) {
    // 0x12b0
    return shmctl(shmid2, cmd, buf);
}

// Address range: 0x12c0 - 0x12cb
struct _IO_FILE * function_12c0(char * filename, char * modes) {
    // 0x12c0
    return fopen(filename, modes);
}

// Address range: 0x12d0 - 0x12db
void function_12d0(char * s) {
    // 0x12d0
    perror(s);
}

// Address range: 0x12e0 - 0x12eb
int32_t function_12e0(int32_t semid, int32_t semnum, int32_t cmd, ...) {
    // 0x12e0
    return semctl(semid, semnum, cmd);
}

// Address range: 0x12f0 - 0x12fb
int64_t * function_12f0(int32_t shmid2, int64_t * shmaddr, int32_t shmflg) {
    // 0x12f0
    return shmat(shmid2, shmaddr, shmflg);
}

// Address range: 0x1300 - 0x130b
int32_t function_1300(int32_t key, int32_t size, int32_t shmflg) {
    // 0x1300
    return shmget(key, size, shmflg);
}

// Address range: 0x1310 - 0x131b
int32_t function_1310(int32_t semid, struct sembuf * sops, int32_t nsops) {
    // 0x1310
    return semop(semid, sops, nsops);
}

// Address range: 0x1320 - 0x132b
void function_1320(int32_t status) {
    // 0x1320
    exit(status);
}

// Address range: 0x1330 - 0x133b
int32_t function_1330(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x1330
    return fwrite(ptr, size, n, s);
}

// Address range: 0x1340 - 0x134b
int32_t function_1340(char * pathname, int32_t proj_id) {
    // 0x1340
    return ftok(pathname, proj_id);
}

// Address range: 0x1350 - 0x135b
int32_t function_1350(int32_t useconds) {
    // 0x1350
    return usleep(useconds);
}

// Address range: 0x1360 - 0x138f
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1360
    int64_t v1; // 0x1360
    __libc_start_main(0x1449, (int32_t)a4, (char **)&v1, (void (*)())0x2110, (void (*)())0x2180, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1390 - 0x13b9
int64_t deregister_tm_clones(void) {
    // 0x1390
    return 0x5010;
}

// Address range: 0x13c0 - 0x13f9
int64_t register_tm_clones(void) {
    // 0x13c0
    return 0;
}

// Address range: 0x1400 - 0x1439
int64_t __do_global_dtors_aux(void) {
    // 0x1400
    if (g8 != 0) {
        // 0x1438
        int64_t result; // 0x1400
        return result;
    }
    // 0x140d
    if (*(int64_t *)0x4ff8 != 0) {
        // 0x141b
        __cxa_finalize((int64_t *)*(int64_t *)0x5008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1427
    g8 = 1;
    return result2;
}

// Address range: 0x1440 - 0x1449
int64_t frame_dummy(void) {
    // 0x1440
    return register_tm_clones();
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemReferee.c
// Address range: 0x1449 - 0x1622
// Line range:    71 - 129
int main(int argc, char ** argv) {
    if (argc != 4) {
        // 0x1462
        freopen("error_RF", "a", g7);
        fwrite((int64_t *)"Number of parameters is incorrect!\n", 1, 35, g7);
        // 0x1620
        return 1;
    }
    int64_t v1 = (int64_t)argv; // 0x14a9
    strcpy(nFic, (char *)*(int64_t *)(v1 + 16));
    freopen((char *)*(int64_t *)(v1 + 24), "w", g7);
    setbuf(g7, NULL);
    int32_t v2 = ftok(".", 97); // 0x1504
    if (v2 == -1) {
        // 0x1512
        perror("error on generating the key");
        exit(1);
        // UNREACHABLE
    }
    int32_t v3 = semConnect(v2); // 0x152d
    semgid = v3;
    if (v3 == -1) {
        // 0x1543
        perror("error on connecting to the semaphore set");
        // 0x1620
        return 1;
    }
    int32_t v4 = shmemConnect(v2); // 0x155e
    shmid = v4;
    if (v4 == -1) {
        // 0x1574
        perror("error on connecting to the shared memory region");
        // 0x1620
        return 1;
    }
    // 0x158a
    if (shmemAttach(v4, (char **)&sh) == -1) {
        // 0x15a3
        perror("error on mapping the shared region on the process address space");
        // 0x1620
        return 1;
    }
    // 0x15b6
    srandom(getpid());
    arrive();
    waitForTeams();
    startGame();
    play();
    endGame();
    int32_t result = 0; // 0x1606
    if (shmemDettach((char *)sh) == -1) {
        // 0x1608
        perror("error on unmapping the shared region off the process address space");
        result = 1;
    }
    // 0x1620
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemReferee.c
// Address range: 0x1622 - 0x16f7
// Line range:    138 - 158
void arrive(void) {
    // 0x1622
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1648
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    // 0x165e
    *(int32_t *)((int64_t)sh + 52) = 65;
    saveState(nFic, sh);
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x16a0
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    int128_t v1 = __asm_mulsd(__asm_movsd(0x4059000000000000), __asm_cvtsi2sd((int64_t)random())); // 0x16c8
    int128_t v2 = __asm_movapd(__asm_divsd(v1, __asm_movsd(0x41e0000000000000))); // 0x16d8
    usleep((int32_t)__asm_cvttsd2si(__asm_addsd(__asm_movsd(0x4024000000000000), v2)));
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemReferee.c
// Address range: 0x16f7 - 0x17c0
// Line range:    167 - 187
void waitForTeams(void) {
    // 0x16f7
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x171d
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    // 0x1733
    *(int32_t *)((int64_t)sh + 52) = 87;
    saveState(nFic, sh);
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) != -1) {
        // 0x178b
        semDown(semgid, *(int32_t *)((int64_t)sh + 108));
        semDown(semgid, *(int32_t *)((int64_t)sh + 108));
        return;
    }
    // 0x1775
    perror("error on the up operation for semaphore access (RF)");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemReferee.c
// Address range: 0x17c0 - 0x18b4
// Line range:    196 - 221
void startGame(void) {
    // 0x17c0
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x17ea
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    // 0x1800
    *(int32_t *)((int64_t)sh + 52) = 83;
    saveState(nFic, sh);
    int32_t v1 = 0; // 0x1840
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1842
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    semUp(semgid, *(int32_t *)((int64_t)sh + 100));
    v1++;
    int32_t v2 = 0; // 0x1882
    while (v1 != 10) {
        // 0x1861
        semUp(semgid, *(int32_t *)((int64_t)sh + 100));
        v1++;
        v2 = 0;
    }
    semDown(semgid, *(int32_t *)((int64_t)sh + 116));
    // v2 = 0; 
    int32_t v3 = v2 + 1; // 0x18a6   v3 = 1;
    v2 = v3;   // v2 = 1;
    while (v3 != 10) {
        // 0x188d
        semDown(semgid, *(int32_t *)((int64_t)sh + 116));
        v3 = v2 + 1;
        v2 = v3;
    }
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemReferee.c
// Address range: 0x18b4 - 0x1989
// Line range:    230 - 247
void play(void) {
    // 0x18b4
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x18da
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    // 0x18f0
    *(int32_t *)((int64_t)sh + 52) = 82;
    saveState(nFic, sh);
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1932
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    int128_t v1 = __asm_mulsd(__asm_movsd(0x4059000000000000), __asm_cvtsi2sd((int64_t)random())); // 0x195a
    int128_t v2 = __asm_movapd(__asm_divsd(v1, __asm_movsd(0x41e0000000000000))); // 0x196a
    usleep((int32_t)__asm_cvttsd2si(__asm_addsd(__asm_movsd(0x408c200000000000), v2)));
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semSharedMemReferee.c
// Address range: 0x1989 - 0x1a51
// Line range:    256 - 277
void endGame(void) {
    // 0x1989
    if (semDown(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x19b3
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    // 0x19c9
    *(int32_t *)((int64_t)sh + 52) = 69;
    saveState(nFic, sh);
    int32_t v1 = 0; // 0x1a09
    if (semUp(semgid, *(int32_t *)((int64_t)sh + 88)) == -1) {
        // 0x1a0b
        perror("error on the up operation for semaphore access (RF)");
        exit(1);
        // UNREACHABLE
    }
    semUp(semgid, *(int32_t *)((int64_t)sh + 104));
    v1++;
    while (v1 != 10) {
        // 0x1a2a
        semUp(semgid, *(int32_t *)((int64_t)sh + 104));
        v1++;
    }
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1a51 - 0x1a7a
// Line range:    35 - 38
int32_t shmemCreate(int32_t key, int32_t size) {
    // 0x1a51
    return shmget(key, size, (int32_t)&g9);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1a7a - 0x1a9f
// Line range:    51 - 54
int32_t shmemConnect(int32_t key) {
    // 0x1a7a
    return shmget(key, 1, 384);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1a9f - 0x1ac4
// Line range:    67 - 70
int32_t shmemDestroy(int32_t shmid2) {
    // 0x1a9f
    return shmctl(shmid2, IPC_RMID, NULL);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1ac4 - 0x1b0f
// Line range:    84 - 94
int32_t shmemAttach(int32_t shmid2, char ** pAttAdd) {
    int64_t * v1 = shmat(shmid2, NULL, 0); // 0x1ae6
    int32_t result = 1; // 0x1af4
    if (v1 != (int64_t *)-1) {
        // 0x1af6
        *(int64_t *)pAttAdd = (int64_t)v1;
        result = 0;
    }
    // 0x1b0d
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/sharedMemory.c
// Address range: 0x1b0f - 0x1b2d
// Line range:    108 - 111
int32_t shmemDettach(char * attAdd) {
    // 0x1b0f
    return shmdt((int64_t *)attAdd);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1b2d - 0x1b5a
// Line range:    39 - 42
int32_t semCreate(int32_t key, int32_t snum) {
    // 0x1b2d
    return semget(key, snum + 1, (int32_t)&g9);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1b5a - 0x1bfb
// Line range:    55 - 65
int32_t semConnect(int32_t key) {
    int64_t v1 = __readfsqword(40); // 0x1b69
    int16_t sops = 0; // bp-28, 0x1b78
    int32_t semid = semget(key, 1, 384); // 0x1bab
    int32_t v2 = -1; // 0x1bb7
    if (semid != -1) {
        // 0x1bc0
        v2 = semop(semid, (struct sembuf *)&sops, 2) != -1 ? semid : -1;
    }
    int32_t result = v2; // 0x1bf2
    if (v1 != __readfsqword(40)) {
        // 0x1bf4
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1bf9
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1bfb - 0x1c2a
// Line range:    78 - 81
int32_t semDestroy(int32_t semgid2) {
    // 0x1bfb
    return semctl(semgid2, 0, IPC_RMID);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1c2a - 0x1c86
// Line range:    94 - 99
int32_t semSignal(int32_t semgid2) {
    int64_t v1 = __readfsqword(40); // 0x1c39
    int16_t sops = 0; // bp-22, 0x1c48
    int32_t result = semop(semgid2, (struct sembuf *)&sops, 1); // 0x1c7d
    if (v1 != __readfsqword(40)) {
        // 0x1c7f
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1c84
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1c86 - 0x1d11
// Line range:    113 - 120
int32_t semDown(int32_t semgid2, int32_t sindex) {
    int64_t v1 = __readfsqword(40); // 0x1c98
    int32_t sops = 0; // bp-22, 0x1ca7
    if (sindex == 0) {
        // 0x1cbf
        __assert_fail("sindex>0", "semaphore.c", 117, "semDown");
    }
    // 0x1cde
    sops = 0x10000 * sindex >> 16;
    int32_t result = semop(semgid2, (struct sembuf *)&sops, 1); // 0x1d08
    if (v1 != __readfsqword(40)) {
        // 0x1d0a
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1d0f
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/semaphore.c
// Address range: 0x1d11 - 0x1d9c
// Line range:    134 - 141
int32_t semUp(int32_t semgid2, int32_t sindex) {
    int64_t v1 = __readfsqword(40); // 0x1d23
    int32_t sops = 0; // bp-22, 0x1d32
    if (sindex == 0) {
        // 0x1d4a
        __assert_fail("sindex>0", "semaphore.c", 138, "semUp");
    }
    // 0x1d69
    sops = 0x10000 * sindex >> 16;
    int32_t result = semop(semgid2, (struct sembuf *)&sops, 1); // 0x1d93
    if (v1 != __readfsqword(40)) {
        // 0x1d95
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1d9a
    return result;
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x1d9c - 0x1e3f
// Line range:    29 - 48
struct _IO_FILE * openLog(char * nFic2, char * mode) {
    // 0x1d9c
    if (nFic2 == NULL) {
        // 0x1e3d
        return g6;
    }
    int64_t v1; // 0x1d9c
    if ((char)v1 == 0) {
        // 0x1e3d
        return g6;
    }
    // 0x1dcb
    fprintf(g7, "%d opening log %s %s\n", (int64_t)getpid(), nFic2, mode);
    struct _IO_FILE * file = fopen(nFic2, mode); // 0x1e13
    if (file != NULL) {
        // 0x1e3d
        return file;
    }
    // 0x1e23
    perror("error on opening log file");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x1e3f - 0x1ea0
// Line range:    50 - 61
void closeLog(struct _IO_FILE * fic) {
    // 0x1e3f
    if (g7 == fic || g6 == fic) {
        // 0x1e69
        fflush(fic);
        // 0x1e9e
        return;
    }
    // 0x1e77
    if (fclose(fic) != -1) {
        // 0x1e9e
        return;
    }
    // 0x1e88
    perror("error on closing of log file");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x1ea0 - 0x1f99
// Line range:    63 - 85
void printHeader(struct _IO_FILE * fic, int32_t * p_fSt) {
    int64_t v1 = (int64_t)p_fSt; // 0x1ee5
    int32_t * v2 = (int32_t *)(v1 + 56); // 0x1ee9
    struct _IO_FILE * stream = (struct _IO_FILE *)(0x100000000 * (int64_t)fic >> 32);
    int32_t v3 = 0; // 0x1eef
    if (*v2 != 0) {
        fprintf(stream, " %s%02d", (char *)&g1, (int64_t)v3);
        v3++;
        while ((int64_t)v3 < (int64_t)*v2) {
            // 0x1ebd
            fprintf(stream, " %s%02d", (char *)&g1, (int64_t)v3);
            v3++;
        }
    }
    // 0x1ef1
    fputc(32, stream);
    int32_t * v4 = (int32_t *)(v1 + 60); // 0x1f37
    int32_t v5 = 0; // 0x1f3d
    if (*v4 == 0) {
        // 0x1f3f
        fputc(32, stream);
        fprintf(stream, " %s%02d", (char *)&g3, 1);
        fputc(32, stream);
        fputc(10, stream);
        return;
    }
    fprintf(stream, " %s%02d", (char *)&g2, (int64_t)v5);
    v5++;
    while ((int64_t)v5 < (int64_t)*v4) {
        // 0x1f0b
        fprintf(stream, " %s%02d", (char *)&g2, (int64_t)v5);
        v5++;
    }
    // 0x1f3f
    fputc(32, stream);
    fprintf(stream, " %s%02d", (char *)&g3, 1);
    fputc(32, stream);
    fputc(10, stream);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x1f99 - 0x2003
// Line range:    101 - 113
void createLog(char * nFic2, int32_t * p_fSt) {
    struct _IO_FILE * stream = openLog(nFic2, "w"); // 0x1fbb
    fprintf(stream, "%21cSoccerGame - Description of the internal state\n\n", 32);
    printHeader(stream, p_fSt);
    closeLog(stream);
}

// From module:   /home/nuno/Dropbox/Aulas/sop_2425/docs/praticas/tg2/semaphore_soccergame_solv/src/logging.c
// Address range: 0x2003 - 0x2110
// Line range:    128 - 153
void saveState(char * nFic2, int32_t * p_fSt) {
    struct _IO_FILE * stream = openLog(nFic2, (char *)0x325d); // 0x2025
    int64_t v1 = (int64_t)p_fSt; // 0x2060
    int32_t * v2 = (int32_t *)(v1 + 56); // 0x2064
    if (*v2 != 0) {
        fprintf(stream, "%4c", (char)*(int32_t *)((0 >> 30) + v1));
        int64_t v3 = 1; // 0x205c
        int64_t v4 = 0x100000000 * v3;
        int64_t v5 = v3 & 0xffffffff; // 0x206a
        while (v4 >> 32 < (int64_t)*v2) {
            // 0x2037
            fprintf(stream, "%4c", (char)*(int32_t *)((v4 >> 30) + v1));
            v3 = v5 + 1;
            v4 = 0x100000000 * v3;
            v5 = v3 & 0xffffffff;
        }
    }
    // 0x206c
    fputc(32, stream);
    int32_t * v6 = (int32_t *)(v1 + 60); // 0x20b8
    if (*v6 != 0) {
        int32_t v7 = 0; // 0x20b0
        fprintf(stream, "%4c", (char)*(int32_t *)(40 + v1));
        v7++;
        int64_t v8 = v7; // 0x20be
        while (v8 < (int64_t)*v6) {
            // 0x2086
            fprintf(stream, "%4c", (char)*(int32_t *)(v1 + 40 + 4 * v8));
            v7++;
            v8 = v7;
        }
    }
    // 0x20c0
    fputc(32, stream);
    fprintf(stream, "%4c", (char)*(int32_t *)(v1 + 52));
    fputc(10, stream);
    closeLog(stream);
}

// Address range: 0x2110 - 0x2175
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = _init(); // 0x213c
    if ((int64_t)&g5 - (int64_t)&g4 >> 3 == 0) {
        // 0x2166
        return result;
    }
    int64_t v1 = 0; // 0x2145
    while (v1 + 1 != (int64_t)&g5 - (int64_t)&g4 >> 3) {
        // 0x2150
        v1++;
    }
    // 0x2166
    return result;
}

// Address range: 0x2180 - 0x2185
int64_t __libc_csu_fini(void) {
    // 0x2180
    int64_t result; // 0x2180
    return result;
}

// Address range: 0x2188 - 0x2195
int64_t _fini(void) {
    // 0x2188
    int64_t result; // 0x2188
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (9.4.0)
// Detected functions: 57

